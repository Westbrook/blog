<!-- this is an example layout -->
{% extends 'default.html' %}

{% block head %}
<link rel="preload" href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<style>
    main {
        float: right;
        text-align: left;
        width: 60ch;
        max-width: calc(100% - 100px);
        line-height: 2;
        padding: 50px 50px 25px;
    }
    main > * {
        font-size: 18px;
    }
    main > h1 {
        margin-left: -25px;
    }
    main p {
        margin: 2em 0;
    }
    pre {
        overflow: auto;
        font-size: 0.85em !important;
    }
    dialog {
        padding: 0;
        border-radius: 0.3em;
        background: #272822;
        max-height: 80%;
        max-width: calc(100% - 50px);
    }
    dialog > pre {
        margin: 0 !important;
    }
    main div {
        margin: 1em 0;
    }
    .customized custom-element {
        color: green;
        border: none;
        padding: 1em 2em;
        font-size: 2rem;
    }
    .customized-2 custom-element {
        color: green;
        border: 3px dotted;
        padding: 1em 2em;
    }
    dialog::backdrop {
        background: rgba(0, 0, 0, 0.3);
    }
    hr {
        width: 60%;
        margin: 3em auto;
        color: inherit;
    }
    @media (max-width: 910px) {
        main {
          margin: 0 auto;
          float: none;
        }
      }
</style>
<script type="module">
    document.addEventListener('click', (event) => {
        const { target } = event;
        const pre = event.composedPath().find(el => el.localName === 'pre');
        if (!!pre && pre.parentElement.localName !== 'dialog') {
            pre.nextElementSibling.append(pre.cloneNode(true));
            pre.nextElementSibling.showModal();
        }
        if (target.localName === 'dialog') {
            target.innerHTML = '';
            target.close();
        }
    });
</script>
{% endblock %}

{% block content %}
<p>In my day-to-day work, I tend to write custom elements using the <a href="https://lit.dev/docs/api/LitElement/" target="_blank">LitElement</a> base class. This is great because it reduces boilerplate, focuses me on the functionality I'm delivering, and enforces at least a baseline normalization of patterns with my coworkers. However, I at least put a passing attempt at writing vanilla web components when bringing together explainers and conversation around non-Lit contexts; see articles on the styling of <a href="/styling/basic">basic custom elements</a> or the <a href="/styling/internals">internals</a> of custom elements. That process often leaves me to think out loud about the patterns that might be useful for leveraging when building many/shared/distributed custom elements with vanilla JS, here's one...</p>
{% include "partials/headline.njk" %}
{{ content | safe }}
<hr>
<p><em><strong>Editors note:</strong></em> some of the APIs outlined in the examples above are not <em>yet</em> available cross-browser. While these are the target APIs that browsers have agreed to, in order to support cross-browser delivery of this article, live demo code is modified from the example to work fully cross-browser.</p>
{% endblock %}