---
layout: layouts/post.html
date: 2022-11-27
modified: 2023-12-30
---

{% block content %}
<h1>Styling the internals of custom elements</h1>
<h3 class="date">First published: {{ page.date | postDate }}</h3>
<h3 class="date">Modified: {{ modified | postDate }}</h3>
<p>In <a href="/styling/basic">"Basic styling of custom elements"</a> we learned that styling a custom element is much like styling any other HTML element. At its very root, this is always true, at least of the custom element itself. However, once the custom element begins to have an internal DOM structure of its own, this starts to change.</p>
<p>Here is the code from our previous example alter in a very arbitrary way to include internal DOM:</p>
{% highlight "js" %}
/* custom-element.js */
import styles from './custom-element.css' with { type: 'css' };
const template = document.createElement("template");
template.innerHTML = /*html*/`
    <div>
        <slot></slot>
    </div>
`;

class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            template.content.cloneNode(true)
        );
        this.shadowRoot.adoptedStyles = [styles];
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>And, our custom element styles updated for this move to internal DOM.</p>
{% highlight "css" %}
/* custom-element.css */
:host {
    display: block;
}
div {
    color: red;
    border: 1px solid;
    padding: 30px;
    font-size: 30px;
}
{% endhighlight %}
<dialog></dialog>
<p>Out of the box, we get almost exactly the same custom element delivery as we had before.</p>
<div>
    <custom-element>This is a custom element!</custom-element>
</div>
However, when applying the custom CSS from the outside that we previously discussed we get:
<div class="customized">
    <custom-element>This is a styled custom element!</custom-element>
</div>
<p>All the way over here, I can hear you saying "But...that's not what we got before!?!" And, you're right, it isn't.</p>
<p>We had previously applied the below styles on top of the default styling of our custom element:</p>
{% highlight "css" %}
/* site.css */
custom-element {
    color: green;
    border: none;
    padding: 1em 2em;
    font-size: 2rem;
}
{% endhighlight %}
<dialog></dialog>
<p>However, with the move to an internal DOM structure and applying our default custom element styles on those internal DOM elements, we're no longer overriding the defaults but adding styles to work in concert with them. The majority of the previously applied styles require direct or inherited access to an element to apply, so the only one we <em>really</em> see is the additional <code>padding</code>. We can apply more impactful styles from the outside, however.</p>
{% highlight "css" %}
/* site.css */
custom-element {
    color: green;
    border: 3px dotted;
    padding: 1em 2em;
}
{% endhighlight %}
<dialog></dialog>
<p>Which looks like this:</p>
<div class="customized-2">
    <custom-element>This is a styled custom element!</custom-element>
</div>
<p>Here we can immediately see how the two lists of style rules are now acting in partnership. What's not yet apparent is how to customize the delivery of the content within the custom element itself. In fact, it's not apparent because as currently structured the custom element that we've developed is specifically preventing the application of external decisions on its internal DOM.</p>
<p>Styling custom element internals (beyond inherited styles) requires some form of contract with the element's author. A number of paths by which this contract can be fulfilled exist, some of them are as follows:</p>
<ul>
    <li>An agreement that the custom element is the Sistine Chapel of custom elements and should always be delivered 100% as is.</li>
    <li>A choice for you to <em>become</em> the custom element author via a <a href="/styling/class-extension">class extension and reregistration</a>.</li>
    <li>The developer surfacing a CSS Custom Property API.</li>
    <li>CSS Parts being made available in the shadow DOM.</li>
    <li>Container query-based "themes" being offered for consumption.</li>
    <li>Stacked slot-based DOM structure for customization with external DOM.</li>
</ul>
<p>Any one of these could be used individually, and/or various approaches could be used in partnership to bring various levels of nuance to a custom element's style customization API. Look for more information on these, and more, soon.</p>
<script>
    const template = document.createElement("template");
    template.innerHTML = /*html*/`
        <style>
            :host {
                display: block;
            }
            div {
                color: red;
                border: 1px solid;
                padding: 30px;
                font-size: 30px;
            }
        </style>
        <div>
            <slot></slot>
        </div>
    `;
    
    class CustomElement extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({
                mode: "open"
            });
            this.shadowRoot.appendChild(
                template.content.cloneNode(true)
            );
        }
    }
    
    customElements.define('custom-element', CustomElement);
</script>
{% endblock %}