<!-- This is using the _includes/default.html template -->
{% extends 'default.html' %}

{% block head %}
<link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
<style>
    main {
        float: right;
        text-align: left;
        width: 60ch;
        max-width: calc(100% - 100px);
        line-height: 2;
        padding: 50px 50px 25px;
    }
    main > * {
        font-size: 18px;
    }
    main > h1 {
        margin-left: -25px;
    }
    main p {
        margin: 2em 0;
    }
    pre {
        overflow: auto;
        font-size: 0.85em !important;
    }
    dialog {
        padding: 0;
        border-radius: 0.3em;
        background: #272822;
        max-height: 80%;
        max-width: calc(100% - 50px);
    }
    dialog > pre {
        margin: 0 !important;
    }
    main div {
        margin: 1em 0;
    }
    .customized custom-element {
        color: green;
        border: none;
        padding: 1em 2em;
        font-size: 2rem;
    }
    .customized-2 custom-element {
        color: green;
        border: 3px dotted;
        padding: 1em 2em;
    }
    dialog::backdrop {
        background: rgba(0, 0, 0, 0.3);
    }
    html:has(dialog[open]) {
        overflow: hidden;
    }
    hr {
        width: 60%;
        margin: 3em auto;
        color: inherit;
    }
    @media (max-width: 910px) {
        main {
          margin: 0 auto;
          float: none;
        }
      }
</style>
<script type="module">
    document.addEventListener('click', (event) => {
        const { target } = event;
        const pre = event.composedPath().find(el => el.localName === 'pre');
        if (!!pre && pre.parentElement.localName !== 'dialog') {
            pre.nextElementSibling.append(pre.cloneNode(true));
            pre.nextElementSibling.showModal();
        }
        if (target.localName === 'dialog') {
            target.innerHTML = '';
            target.close();
        }
    });
</script>
{% endblock %}

{% block content %}
<h1>Styling the internals of custom elements</h1>
<p>In <a href="/styling/basic">"Basic styling of custom elements"</a> we learned that styling a custom element is much like styling any other HTML element. At its very root, this is always true, at least of the custom element itself. However, once the custom element begins to have an internal DOM structure of its own, this starts to change.</p>
<p>Here is the code from our previous example alter in a very arbitrary way to include internal DOM:</p>
{% highlight "js" %}
/* custom-element.js */
import styles from './custom-element.css' assert { type: 'css' };
const template = document.createElement("template");
template.innerHTML = /*html*/`
    <div>
        <slot></slot>
    </div>
`;

class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            template.content.cloneNode(true)
        );
        this.shadowRoot.adoptedStyles = [styles];
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>And, our custom element styles updated for this move to internal DOM.</p>
{% highlight "css" %}
/* custom-element.css */
:host {
    display: block;
}
div {
    color: red;
    border: 1px solid;
    padding: 30px;
    font-size: 30px;
}
{% endhighlight %}
<dialog></dialog>
<p>Out of the box, we get almost exactly the same custom element delivery as we had before.</p>
<div>
    <custom-element>This is a custom element!</custom-element>
</div>
However, when applying the custom CSS from the outside that we previously discussed we get:
<div class="customized">
    <custom-element>This is a styled custom element!</custom-element>
</div>
<p>All the way over here, I can hear you saying "But...that's not what we got before!?!" And, you're right, it isn't.</p>
<p>We had previously applied the below styles on top of the default styling of our custom element:</p>
{% highlight "css" %}
/* site.css */
custom-element {
    color: green;
    border: none;
    padding: 1em 2em;
    font-size: 2rem;
}
{% endhighlight %}
<dialog></dialog>
<p>However, with the move to an internal DOM structure and applying our default custom element styles on those internal DOM elements, we're no longer overriding the defaults but adding styles to work in concert with them. The majority of the previously applied styles require direct or inherited access to an element to apply, so the only one we <em>really</em> see is the additional <code>padding</code>. We can apply more impactful styles from the outside, however.</p>
{% highlight "css" %}
/* site.css */
custom-element {
    color: green;
    border: 3px dotted;
    padding: 1em 2em;
}
{% endhighlight %}
<dialog></dialog>
<p>Which looks like this:</p>
<div class="customized-2">
    <custom-element>This is a styled custom element!</custom-element>
</div>
<p>Here we can immediately see how the two lists of style rules are now acting in partnership. What's not yet apparent is how to customize the delivery of the content within the custom element itself. In fact, it's not apparent because as currently structured the custom element that we've developed is specifically preventing the application of external decisions on its internal DOM.</p>
<p>Styling custom element internals (beyond inherited styles) requires some form of contract with the element's author. A number of paths by which this contract can be fulfilled exist, some of them are as follows:</p>
<ul>
    <li>An agreement that the custom element is the Sistine Chapel of custom elements and should always be delivered 100% as is.</li>
    <li>A choice for you to <em>become</em> the custom element author via a class extension and reregistration.</li>
    <li>The developer surfacing a CSS Custom Property API.</li>
    <li>CSS Parts being made available in the shadow DOM.</li>
    <li>Container query-based "themes" being offered for consumption.</li>
    <li>Stacked slot-based DOM structure for customization with external DOM.</li>
</ul>
<p>Any one of these could be used individually, and/or various approaches could be used in partnership to bring various levels of nuance to a custom element's style customization API. Look for more information on these, and more, soon.</p>
<hr>
<p><em><strong>Editors note:</strong></em> some of the APIs outlined in the examples above are not <em>yet</em> available cross-browser. While these are the target APIs that browsers have agreed to, in order to support cross-browser delivery of this article, live demo code is modified from the example to work fully cross-browser.</p>
<script>
    const template = document.createElement("template");
    template.innerHTML = /*html*/`
        <style>
            :host {
                display: block;
            }
            div {
                color: red;
                border: 1px solid;
                padding: 30px;
                font-size: 30px;
            }
        </style>
        <div>
            <slot></slot>
        </div>
    `;
    
    class CustomElement extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({
                mode: "open"
            });
            this.shadowRoot.appendChild(
                template.content.cloneNode(true)
            );
        }
    }
    
    customElements.define('custom-element', CustomElement);
    </script>
{% endblock %}