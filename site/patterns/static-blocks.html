---
layout: layouts/patterns.html
title: Static blocks in JS classes
date: 2022-11-26
---

{% block content %}
<p>Classes in JS have had <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#static_methods_and_properties" target="_blank">static properties and methods</a> for some time. Place a static property on a class, and only access that value through the class:</p>
{% highlight "js" %}
class Awesome {
    static amount = '100%';
}

console.log(Awesome.amout); // 100%

console.log(new Awesome().amount); // undefined;
{% endhighlight %}
<dialog></dialog>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks" target="_blank">Static blocks</a> take this one step further by allowing you a define time mechanism by which to functionally work on those values. So, much in the way a <code>constructor</code> would be called once every time a new instance of the class is created, these static blocks would be called once every time the class was defined.</p>
{% highlight "js" %}
class Awesome {
    constructor() {
        console.log('construct');
    }
    static {
        console.log('static block');
    }
}

// static block
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
{% endhighlight %}
<dialog></dialog>
<p>I'll be honest with you in saying that the above examples leave me a bit nonplused. Even the examples on MDN seem to border right on the edge of frivolity when taking into account the way I tend to work with JS classes. However, there is one pattern this does remind me of; the way vanilla custom element look to share a single base template from which they can clone their shadow root.</p>
{% highlight "js" %}
const template = document.createElement("template");
template.innerHTML = /*html*/`
    <slot></slot>
`;

class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            template.content.cloneNode(true)
        );
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>You see that <code>template</code> variable hanging of what's likely a JS module like a class in and of itself, but requiring some initialization hand-holding? Well, what if we placed that in a static block?</p>
{% highlight "js" %}
class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );
    }
    static template;
    static {
        this.template = document.createElement("template");
        this.template.innerHTML = /*html*/`
            <slot></slot>
        `;
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>Technically, you could go a few steps further, if you liked this pattern.</p>
{% highlight "js" %}
class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            this.template()
        );
    }
    static template;
    static {
        const template = document.createElement("template");
        const template.innerHTML = /*html*/`
            <slot></slot>
        `;
        this.template = () => template.content.cloneNode(true);
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>The way this refocuses all that is the custom element back into the custom element's class definition is kind of nice. It also opens up some new areas of code reusability to explore by making somewhat equal paths to consuming the custom element definition as a custom element <em>and</em> as a DOM snippet. You can see a version of this style of reuse in a project by Rody Davis that he's called <a href="https://github.com/rodydavis/lit-modules" target="_blank">lit-modules</a>. Fully exploring what they might actually open up to a developer is a pattern exploration for another day, but it does feel that as soon as static blocks get full cross-browser support that there may be something interesting to pursue there.</p>
{% endblock %}