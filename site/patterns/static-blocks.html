<!-- This is using the _includes/default.html template -->
{% extends 'default.html' %}

{% block head %}
<link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
<style>
    main {
        float: right;
        text-align: left;
        width: 60ch;
        max-width: calc(100% - 100px);
        line-height: 2;
        padding: 50px 50px 25px;
    }
    main > * {
        font-size: 18px;
    }
    main > h1 {
        margin-left: -25px;
    }
    main p {
        margin: 2em 0;
    }
    pre {
        overflow: auto;
        font-size: 0.85em !important;
    }
    dialog {
        padding: 0;
        border-radius: 0.3em;
        background: #272822;
        max-height: 80%;
        max-width: calc(100% - 50px);
    }
    dialog > pre {
        margin: 0 !important;
    }
    main div {
        margin: 1em 0;
    }
    .customized custom-element {
        color: green;
        border: none;
        padding: 1em 2em;
        font-size: 2rem;
    }
    dialog::backdrop {
        background: rgba(0, 0, 0, 0.3);
    }
    html:has(dialog[open]) {
        overflow: hidden;
    }
    hr {
        width: 60%;
        margin: 3em auto;
        color: inherit;
    }
    @media (max-width: 910px) {
        main {
          margin: 0 auto;
          float: none;
        }
      }
</style>
<script type="module">
    document.addEventListener('click', (event) => {
        const { target } = event;
        const pre = event.composedPath().find(el => el.localName === 'pre');
        if (!!pre && pre.parentElement.localName !== 'dialog') {
            pre.nextElementSibling.append(pre.cloneNode(true));
            pre.nextElementSibling.showModal();
        }
        if (target.localName === 'dialog') {
            target.innerHTML = '';
            target.close();
        }
    });
</script>
{% endblock %}

{% block content %}
<p>In my day-to-day work, I tend to write custom elements using the <a href="https://lit.dev/docs/api/LitElement/" target="_blank">LitElement</a> base class. This is great because it reduces boilerplate, focuses me on the functionality I'm delivering, and enforces at least a baseline normalization of patterns with my coworkers. However, I at least put a passing attempt at writing vanilla web components when bringing together explainers and conversation around non-Lit contexts; see articles on the styling of <a href="/styling/basic">basic custom elements</a> or the <a href="/styling/internals">internals</a> of custom elements. That process often leaves me to think out loud about the patterns that might be useful for leveraging when building many/shared/distributed custom elements with vanilla JS, here's one...</p>
<h1>Static blocks in JS classes</h1>
<p>Classes in JS have had <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#static_methods_and_properties" target="_blank">static properties and methods</a> for some time. Place a static property on a class, and only access that value through the class:</p>
{% highlight "js" %}
class Awesome {
    static amount = '100%';
}

console.log(Awesome.amout); // 100%

console.log(new Awesome().amount); // undefined;
{% endhighlight %}
<dialog></dialog>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Static_initialization_blocks" target="_blank">Static blocks</a> take this one step further by allowing you a define time mechanism by which to functionally work on those values. So, much in the way a <code>constructor</code> would be called once every time a new instance of the class is created, these static blocks would be called once every time the class was defined.</p>
{% highlight "js" %}
class Awesome {
    constructor() {
        console.log('construct');
    }
    static {
        console.log('static block');
    }
}

// static block
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
new Awesome(); // construct
{% endhighlight %}
<dialog></dialog>
<p>I'll be honest with you in saying that the above examples leave me a bit nonplused. Even the examples on MDN seem to border right on the edge of frivolity when taking into account the way I tend to work with JS classes. However, there is one pattern this does remind me of; the way vanilla custom element look to share a single base template from which they can clone their shadow root.</p>
{% highlight "js" %}
const template = document.createElement("template");
template.innerHTML = /*html*/`
    <slot></slot>
`;

class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            template.content.cloneNode(true)
        );
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>You see that <code>template</code> variable hanging of what's likely a JS module like a class in and of itself, but requiring some initialization hand-holding? Well, what if we placed that in a static block?</p>
{% highlight "js" %}
class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            this.template.content.cloneNode(true)
        );
    }
    static template;
    static {
        this.template = document.createElement("template");
        this.template.innerHTML = /*html*/`
            <slot></slot>
        `;
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>Technically, you could go a few steps further, if you liked this pattern.</p>
{% highlight "js" %}
class CustomElement extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({
            mode: "open"
        });
        this.shadowRoot.appendChild(
            this.template()
        );
    }
    static template;
    static {
        const template = document.createElement("template");
        const template.innerHTML = /*html*/`
            <slot></slot>
        `;
        this.template = () => template.content.cloneNode(true);
    }
}

customElements.define('custom-element', CustomElement);
{% endhighlight %}
<dialog></dialog>
<p>The way this refocuses all that is the custom element back into the custom element's class definition is kind of nice. It also opens up some new areas of code reusability to explore by making somewhat equal paths to consuming the custom element definition as a custom element <em>and</em> as a DOM snippet. You can see a version of this style of reuse in a project by Rody Davis that he's called <a href="https://github.com/rodydavis/lit-modules" target="_blank">lit-modules</a>. Fully exploring what they might actually open up to a developer is a pattern exploration for another day, but it does feel that as soon as static blocks get full cross-browser support that there may be something interesting to pursue there.</p>
{% endblock %}